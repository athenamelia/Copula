---
title: "An exploration of nested Archimedean copulas random forest model"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{my-vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
header-includes:
  - \usepackage{booktabs}
  - \usepackage{amsmath}
  - \usepackage{relsize}
bibliography: bibliography.bib
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(ncopula)
library(HAC)
library(copula)
library(gridExtra)
library(ggplot2)
library(readr)
library(MASS)
library(latex2exp)
library(GGally)
```


### Abstract

Creating statistical models that generate accurate nesting structure is challenging, especially for copula models with different strict parameter constraints. This paper provides new procedures for exploring nested Archimedean copula dependency structure and evaluating a nested Archimedean copulas random forest model by averaging multiple copulas with different hierarchical structures. The approach is built on the estimation routines in the HAC package. 

Keywords: Archimedean copulas, nested Archimedean copulas, mixture copulas, random forest

### 1. Introduction
In the "Hierarchical Archimedean Copulae: The HAC Package", Okhrin and Ristig provide methods for estimating the parameters of nested Archimedean copulas through recursion. The general procedure begins with fitting every pair of variables  with a bivariate copula model. The strongest dependency is selected and the corresponding variables are grouped together as the smallest copula at the bottom of the nested Archimedean tree. The copula value with the estimated parameter at this level $\hat{\theta}_{1}$ is now defined as a pseudo-variable $Z_{I_{1}} = C\{(I_{1};\hat{\theta}_{1};\phi_{1}\}$ where $I_{1}$ denotes the variables that are combined. It then is used to select the copula at the next level. The same procedure is repeated until a fixed threshold is reached or there is no variable left to be considered.[@okhrin2012hierarchical]

One of the 4 estimation methods provided in the article is quasi maximum log-likelihood estimation which requires a predetermined nesting structure. We will build our procedure on this estimation routine which corresponds to method 1 in the `estimate.copula` function in the HAC package. In our algorithm, we select multiple different nesting structures based on their measure of association and construct a random forest copula with these nesting structures as the component models. It turns out that the averaging the mixture of different copulas returns a valid copula, which indicates that the random forest copula is valid. Proof is represented later in this paper. 

### 2. Description of copulas
#### 2.1. Definition of copulas

Copula is a joint function that measures the dependence between variables with standard uniform margins $U(0,1)$. By Sklar's Theorem, copula is the distribution function H of a d-dimensional random vector $X = (X_{1}, ..., X_{d})$ calculated via

$H(x) = C(F_{1}(x_{1}),...,F_{d}(x_{d}), x \in R^{d}$

where copula $C$ represents the dependence structure of the variables and $F_{1},...,F_{d}$ represents univariate marginal distribution functions of $X$ such that $F_{j}(x_{j}) = H(\infty,...,\infty,x_{j},\infty,...,\infty), x_{j} \in R.$ [@hofert2019elements]

#### 2.2. Cumulative distribution function and probability distribution function calculated with a copula

The cumulative distribution function, or the copula value, is calculated with the marginal distribution functions as the inputs.  
$C(F_{1}(x_{1}),...,F_{d}(x_{d}), x \in R^{d}$

The probability density function $c(u)$ is the derivative of the copula function $C(u)$ where $u_{i}$ is the density of standard uniform margins $U_{i} = U(0,1)$. 

$c(u) = \frac{\partial^d}{\partial u_{d}...\partial u_{1}}C(u_{1},...,u_{d}), u \in (0,1)^{d}$

#### 2.3. Probability integral transformation

Since copula can only measure the dependence of variables whose margins have standard uniform distribution $\text{U}(0,1)$, we can use probability integral transformation to assure that this condition is satisfied. The probability transformation will transform a vector of variables $X = (X_{1}, ..., X_{d})$ with $X \sim F$ into a random vector $U = F(X)$ such that $U_{1}, \cdots, U_{d} \overset{iid}{\sim} \text{U}(0,1)$. New random variable $U$ is denoted

$U_{i,n} = (F_{n,1}(X_{i1}),...,F_{n,d}(X_{id})), i \in \{1,...,n\}$

There are two ways margins $U_{i,n}$ can be estimated: parametrically and nonparametrically. However, it is not guaranteed that the margins are correctly specified, that is, for $i \in \{1, \cdots, d\}, F_{i} \neq \mathcal{F_{i}}$, which may result in the biased $U_{i,n}$ and affect the estimation of copula parameter $\theta_{0}$. One approach to address this problem is to estimate the margins nonparametrically. The  marginal distribution functions are estimated by the empirical dfs of the component sample of $X_{1},...,X_{n}$. Specifically, for any $j \in \{1,...,d\}, F_{j}$ is estimated by

$F_{n,j}(x) = \frac{1}{n+1}\sum_{i=1}^{n}1(X_{ij}\leq x), x \in R.$

From these nonparametrically estimated margins, we can form sample

$U_{i,n} = (F_{n,1}(X_{i1}),...,F_{n,d}(X_{id})), i \in \{1,...,n\}$

$U_{i,n}$ is called $pseudo-observations$ with uniform marginal distributions from which the copula parameter $\theta_{0}$ can be estimated.

1) Here is a single variable $X_{1}$ with values on the horizontal axis, pdf and cdf, with a sample of values of $X_{i1},... X_{in}$ along the horizontal axis and their correspnding pseudo-obs $U_{i1}, ... U_{in}$ along the vertical axis in the cdf plot. 

```{r}
# simulated data of n = 100 independent observations and 10 variables with normal distribution
X <- matrix(rnorm(n = 100*10), nrow = 100, ncol = 10)
# pseudo-observation U with uniform marginal distribution
U <- pobs(X)
```

```{r}
n <- 100
x <- seq(from = min(X[,1]), to = max(X[,1]), by = 0.01)

model_fit <- data.frame(
  x = x,
  dfit = dnorm(x, mean = mean(X[,1]), sd = sqrt((n-1)/n) * sd(X[,1])), 
  pfit = pnorm(x, mean = mean(X[,1]), sd = sqrt((n-1)/n) * sd(X[,1]))
)

p1 <- ggplot(data = as.data.frame(X), mapping = aes(x = X[,1])) +
  geom_line(data = model_fit, mapping = aes(x = x, y = pfit), color = "black") +
  labs(title = 'Cumulative distribution function') +
  xlab(TeX("$X_{1}$")) + 
  ylab(TeX("$U_{1}$")) 

p2 <- ggplot(data = as.data.frame(X), mapping = aes(x = X[,1])) +
  geom_line(data = model_fit, mapping = aes(x = x, y = dfit), color = "black") +
  labs(title = 'Probability density function') +
  xlab(TeX("$X_{1}$")) + 
  ylab("density")

grid.arrange(p1, p2, ncol = 2)
```

2) Scatter plot of samples ($X_{i1}, X_{i2}$) drawn from their joint distribution and corresponding pairs ($U_{i1}, U_{i2}$) 

```{r}
p3 <- ggplot() + 
  geom_point(data = as.data.frame(X[,1:2]), mapping = aes(x = X[,1], y = X[,2]), color = "black") +
  xlab(TeX("$X_{1}$")) + 
  ylab(TeX("$X_{2}$"))

p4 <- ggplot() + 
  geom_point(data = as.data.frame(U[,1:2]), mapping = aes(x = U[,1], y = U[,2]), color = "black") +
  xlab(TeX("$U_{1}$")) + 
  ylab(TeX("$U_{2}$"))

grid.arrange(p3, p4, ncol = 2)
```


#### 2.3. Nested Archimedean copulas

An $Archimedean \space copula$ is a copula of the form $C(u) = \psi(\psi^{-1}(u_{1}) + \cdots + \psi^{-1}(u_{d}), \textbf{u} \in [0,1]^{d},$ for some generator function $\psi$. A $generator$ is a nonincreasing continuous function $\psi: [0, \infty] \rightarrow [0,1]$ which satisfies $\psi(0) = 1$ and $\psi(\infty) = 0$ and is stricty decreasing on $[0, inf\{t: \psi(t) = 0\}].$ [@hofert2019elements]

An extended version of Archimedean copulas is nested Archimedean copulas, which allows more flexibility with asymmetry. There are two of nesting: $fully$ and $partially$. If $d-dimensional$ the Archimedean copula is $fully$ nested, it means that each sub-copula $C(u_{i}, \cdots, u_{d})$ is nested inside an outer copula $C(u_{i+1}, \cdots, u_{d})$ recursively and it measures $d-1$ different pairwise dependencies between every couple of variables; one variable is $X_{i} = \psi_{i}(\psi_{i}^{-1})$ and the other is copula value $c(u_{i+1}, \cdots, u_{d}) = \psi_{0}^{-1}(C(u_{i+1}, \cdots, u_{d}; \psi_{i+1}, \cdots, \psi_{d-2}))$. The full notation is illustrated below:

$C(u_{1}, \cdots, u_{d}; \psi_{0}, \cdots, \psi_{d-2} = \psi_{0}(\psi_{0}^{-1}(u_{1}) + \psi_{0}^{-1}(C(u_{2}, \cdots, u_{d}; \psi_{1}, \cdots, \psi_{d-2})))$

$Partially$ nested Archimedean copulas contains multiple copulas that are separated from each each other, whose values are considered equivalent to pseudo-observation $U_{i}$  

$C(\textbf u) = C(C(u_{11}, \cdots, u_{1d_{1}}; \psi_{1}), \cdots, C(u_{s1}, \cdots, u_{sd_{1}}; \psi_{0}))$

where $u_{ij} \in I, i \in \{1, \cdots, s\}, j \in \{1, \cdots, d_{i}\}$, $s$ is the sum of $sectors$ and $d = \sum_{i=1}^{s} d_{i}$ is the dimension. 

#### 2.4. Archimedean copula parameters have restrictions 

For $C(u_{1}, \cdots, u_{d}; \psi_{0}, \cdots, \psi_{d-2})$ to be a valid copula, $\psi_{i} \in \psi_{\infty}$ for $i\in \{0, \cdots, d-2\}$ has to satisfy that $\psi_{k}^{-1} \space o \space \psi_{k+1}$ is completely monotone derivative for any $k \in \{0, \cdots, d-3\}$. These parameter contraints assure that the $sufficient \space nesting \space condition$ is satisfied. In other words, the tree structure needs to follow the increasing strength of dependency from the bottom to the top of the copula tree. Intuitively, the strongest correlated variables are joined at the lowest floor of the nested copula tree and their connection becomes weaker as we consider the outer copula. Table 2 lists generators that are give completely monotone. 

##### Table 2: Completely monotone Archimedean generators with parameter restrictions for sufficient nesting condition - Nelsen (1998).

|Family |$\vartheta_{i}$|                   $\psi_{i}(t)$                          |          $(\psi_{0}^{-1}$ o $\psi_{0}^{-1})'$ c.m.                               |
|-------|---------------|----------------------------------------------------------|----------------------------------------------------------------------------------|
|Clayton| $(0, \infty)$ | $(1+t)^{-1/\vartheta_{i}}$                               | $\vartheta_{0}, \vartheta_{1} \in (0, \infty) : \vartheta_{0} \leq \vartheta_{1}$|
|AMH    | $[0, 1)$      | $(1-\vartheta_{i})/(e^{t}-\vartheta_{i})$                | $\vartheta_{0}, \vartheta_{1} \in [0, 1) : \vartheta_{0} \leq \vartheta_{1}$     |
|Gumbel | $[1, \infty)$ | exp$(-1^{1/\vartheta_{i}})$                              | $\vartheta_{0}, \vartheta_{1} \in (0, \infty) : \vartheta_{0} \leq \vartheta_{1}$|
|Frank  | $(0, \infty)$ | $-($log$(e^{-t}(e^{-\vartheta_{i}}-1)+1))/\vartheta_{i}$ | $\vartheta_{0}, \vartheta_{1} \in [1, \infty) : \vartheta_{0} \leq \vartheta_{1}$|
|Joe    | $[1, \infty)$ | $1-(1-e^{-t})^{1/\vartheta_{i}}$                         | $\vartheta_{0}, \vartheta_{1} \in [1, \infty) : \vartheta_{0} \leq \vartheta_{1}$|
|12     | $[1, \infty)$ | $(1+t^{1/\vartheta_{i}})^{-1}$                           | $\vartheta_{0}, \vartheta_{1} \in [1, \infty) : \vartheta_{0} \leq \vartheta_{1}$|
|13     | $1, \infty)$  | exp$(1-(1+t)^{1/\vartheta_{i}})$                         | $\vartheta_{0}, \vartheta_{1} \in [1, \infty) : \vartheta_{0} \leq \vartheta_{1}$|
|14     | $[1, \infty)$ | $(1+t^{1/\vartheta_{i}})^{-\vartheta_{i}}$               | $\vartheta_{0}, \vartheta_{1} \in [1, \infty) : \vartheta_{0} \in \mathbb{N}, \leq\vartheta_{1}/\vartheta_{0} \in \mathbb{N}$ |
|19     | $(0, \infty)$ | $\vartheta_{i}/$log$(t+e^{\vartheta_{i}})$               | $\vartheta_{0}, \vartheta_{1} \in (0, \infty) : \vartheta_{0} \leq \vartheta_{1}$|
|20     | $(0, \infty)$ | $($log$(t+e))^{-1/\vartheta_{i}}$                        | $\vartheta_{0}, \vartheta_{1} \in (0, \infty) : \vartheta_{0} \leq \vartheta_{1}$|


The copula generators will be evaluated pair-wise and may not satisfy the sufficient condition if the copulas come from different families. Table 3 lists parameter constraints for generators to be completely monotone, which results in a valid nesting structure. [@hofert2008sampling] 

##### Table 3: Proper family combination and parameter restrictions for sufficient nesting condition - Nelsen (1998). 

|Family combination |$\vartheta_{0}$|   $\vartheta_{1}$  |  $(\psi_{0}^{-1}$ o $\psi_{0}^{-1})'$ c.m. |
|-------------------|---------------|--------------------|--------------------------------------------|
|(Clayton, 12)      | $(0, \infty)$ |   $[1, \infty)$    | $\vartheta_{0}\in (0,1]$                   |
|(Clayton, 14)      | $(0, \infty)$ |   $[1, \infty)$    | $\vartheta_{0}\vartheta_{1} \in (0, 1]$    |                            
|(Clayton, 19)      | $(0, \infty)$ |   $(0, \infty)$    | $\vartheta_{0} \in (0, 1]$                 |                          
|(Clayton, 20)      | $(0, \infty)$ |   $(0, \infty)$    | $\vartheta_{0} \leq \vartheta_{1} $        |                                  
|(Gumbel, Clayton)  | $[0,1)$       |   $(0, \infty)$    | $\vartheta_{1} \in [1, \infty)$            |                           
|(Gumbel, 19)       | $[0,1)$       |   $(0, \infty)$    | any $\vartheta_{0}, \vartheta_{1}$         |                                    
|(Gumbel, 20)       | $[0,1)$       |   $(0, \infty)$    | any $\vartheta_{0}, \vartheta_{1}$         |                                   

#### 2.5. Random forest copula - a valid mixture

A mixture of copulas is a combination of $d$-dimensional copulas with $d \geq 2$, each copula with a specific weight such that $0 \leq w_{k} \leq 1$ and $\sum_{k=1}^{m} W_{k} = 1$. Since each tree structure meets $sufficient \space nesting \space condition$ with satisfying parameters for corresponding copula families, the mixture copula is constructed based on valid component copula models. Assume that each component copula $C_{k} for k \in \{1, \cdots, m\}$ has the corresponding density $c_{k}$, the mixture copula $\text{mix}_{w}(C_{1}, \cdots, C_{m})$ has density 

$\text{mix}_{w}(c_{1}, \cdots, c_{m})(\textbf{u}) = \sum_{k=1}^{m}w_{k}c_{k}(\textbf{u})$ [@hofert2019elements]

Thus, it is plausible to combine different tree structures to obtain a random forest copula model. In the random forest copula model, all $m$ component models are copulas with equal weight $W_{C_{i}} = \frac{1}{m}$ where $i \in \{1, \cdots, m \}$; each component copula model is trained on $\frac{2}{3}$ of the original dataset with replacement. With the bootstrap aggregation technique, random forest copula model guarantees that each component copula model is independent of each other and it is expected to improve the model performance by decreasing the variance of all component copula models. 

${C}^\text{mix}(C_{1}, \cdots, C_{m})(\textbf{u}) = \frac{1}{m}C_{1}(\textbf{u}) + \cdots + \frac{1}{m}C_{m}(\textbf{u}), \textbf{u} \in [0,1]^{d}$ 

### 3. Methods to construct a random forest copula model
#### 3.1. Selecting copula structure of each component copula model

Our algorithm produces multiple different tree structures based on the correlation of the variables. Naturally, the most correlated pair of variables is grouped at the bottom of the tree and the variables including the copula value of the previously grouped couple of variables are recursively evaluated pair-wise. However, this recursive approach returns only one possible tree structure. For the algorithm to produce more than one possible hierarchical structure, a more flexible approach enables evaluting the association among more than two variables at a time or determining whether certain copulas are $siblings$, that is, they are nested within the same parent copula, or $parent-child$. In addition, the strongest correlated connection might not be the most nested copula if compared to other associations, the difference in the measure of correlations is not very large. This could be done by setting a user-specficied threshold to decide the hierarchical ranking and aggregation possibilities in the each tree. 

#### 3.2. Selecting copula family of each component copula model

Each tree in the random forest is family consistent. In other words, each component model is a nested Archimedean copula composed of small sub-copulas that belong to the same copula family. We decide to construct the random forest this way because each copula family has different parameter restrictions for $sufficient \space nesting \space condition$ and combining different families is very complicated with more parameter restrictions. In addition to that challenge, only one common family combination Clayton - Gumbel is proved to satisfy the nesting condition, while others remain unknown. 

Copula family is determined based on the tail dependence of bivariate distributions. Different copula families have different pattern in the depedence of their bivariate tails. Particularly, Clayton copula has lower tail dependence, while Gumbel copula has upper tail dependence. An alternative strategy is to use $Rosenblatt \space transform$ as a graphical goodness-of-fit test to determine the appropriate copula because of the property 

given copula $C'$ and $\textbf{U} \sim C$, $R_{C'}(\textbf{U}) \sim \prod$ if and only if $C' = C$. [@hofert2019elements]

#### 3.3. Constructing random forest copula model

Once we have obtained multiple different nesting structures, the next step is to construct a random forest copula model with these nesting structures as the component copula trees. The parameters of these component model are estimated with quasi MLE approach, corresponding to the method 1 in the `estimate.copula` function in the HAC package. After these parameters are estimated, they will be updated in the corresponding nesting structures and hence, in the random forest copula model. Specifically, $\theta_{rf} = \frac{1}{m} \sum_{k=1}^{m}\theta_{k}$ where $\theta_{k}$ is calculated based on the estimated parameters $\theta_{k1}, \cdots, \theta_{kd}$ from component copula $C_{k}$ for $k \in \{1, \cdots, m\}$. The average log-likelihood value of the random forest copula model is expected to be larger than any of the component copula trees, indicating that the random forest copula is superior. 

### 4. Simulation Studies
#### 4.1. Data simulation from a single NAC 

This code below is adapted from Hierarchical Archimedean Copulae: The HAC package by Okhrin, Ristig. [@okhrin2012hierarchical]

The example below uses the `rHAC` function provided in the HAC package, which generates the variables randomly with a predetermined tree structure. 

```{r}
# sample data from the book, type 1 Gumbel copula
tree = list(list("X1", "X5", 3), list("X2", "X3", "X4", 4), 2)
HAC = hac(type = 1, tree = tree) 
x = rHAC(100, HAC)
est.obj = estimate.copula(x, method = 1, hac = HAC, epsilon = 0.1)
plot(est.obj)
```

Here is an example with similated data. 
 
```{r}
# simulated data
n <- 1000
x_mu <- c(0, 0, 0)
x_sigma <- matrix(c(1,.8,.7,
                    .8,1,.3, 
                    .7,.3,1), 3, 3)
x_multinom <- matrix(mvrnorm(n = n, mu = x_mu , x_sigma), nrow = 100, ncol = 3)
ggpairs(as.data.frame(x_multinom))

# U obtained manually
U_multinom <- cbind(pnorm(x_multinom[,1], mean = mean(x_multinom[,1]),
                 sd = sqrt((n-1)/n) * sd(x_multinom[,1])),
                   pnorm(x_multinom[,2], mean = mean(x_multinom[,2]),
                 sd = sqrt((n-1)/n) * sd(x_multinom[,2])),
                    pnorm(x_multinom[,3], mean = mean(x_multinom[,3]),
                 sd = sqrt((n-1)/n) * sd(x_multinom[,3])))


U_multinom <- cbind(pnorm(x_multinom[,1], mean = 0, sd = 1),
                    pnorm(x_multinom[,2], mean = 0, sd = 1),
                    pnorm(x_multinom[,3], mean = 0, sd = 1))
hist(U_multinom[,1])
colnames(U_multinom) <- c("U1", "U2", "U3")

# using pobs function
U_multinom_obs <- pobs(x_multinom)
colnames(U_multinom_obs) <- c("U1", "U2", "U3")
hist(U_multinom_obs[,1])

# estimate two trees
tree_A <- list(list("U1", "U2", 6), "U3", 5)
modelA <- hac(type = 3, tree = tree_A) 
est.treeA <- estimate.copula(U_multinom, method = 2, hac = modelA, epsilon = 0.1)
est.treeA
plot(est.treeA)

tree_B <- list(list("U1", "U3", 6), "U2", 5)
modelB <- hac(type = 3, tree = tree_B) 
est.treeB <- estimate.copula(U_multinom, method = 2, hac = modelB, epsilon = 0.1)
est.treeB
plot(est.treeB)

# simulate n = 1000 for the test set
n <- 10000
x_test <- matrix(mvrnorm(n = n, mu = x_mu , x_sigma), nrow = 100, ncol = 3)
U_test <- cbind(pnorm(x_test[,1], mean = mean(x_test[,1]),
                 sd = sqrt((n-1)/n) * sd(x_test[,1])),
                    pnorm(x_test[,2], mean = mean(x_test[,2]),
                 sd = sqrt((n-1)/n) * sd(x_test[,2])),
                    pnorm(x_test[,3], mean = mean(x_test[,3]),
                 sd = sqrt((n-1)/n) * sd(x_test[,3])))
colnames(U_test) <- c("U1", "U2", "U3")
ggpairs(as.data.frame(x_test))
est.test_treeA <- estimate.copula(U_test, method = 2, hac = modelA)
plot(est.test_treeA)
est.test_treeB <- estimate.copula(U_test, method = 2, hac = modelB)
plot(est.test_treeB)

# compare log-likelihood
update_modelA <- hac(type = 3, tree = list(list("U1", "U2", 1), "U3", 1))
update_modelB <- hac(type = 3, tree = list(list("U1", "U3", 1.03), "U2", 1)) 

density_treeA <- sum(dHAC(U_test, update_modelA))
density_treeB <- sum(dHAC(U_test, update_modelB))
density_mix <- density_treeA * 0.5 + density_treeB * 0.5

density_treeA
density_treeB
density_mix
```

### 5. Applications
```{r}
# a single “optimal” NAC as selected by the estimation function from the HAC package
wine_red <- read.csv("data/wine_red.csv")
wine_red_df <- as.data.frame(wine_red)
X  <- wine_red_df[-c(1296, 1297), -12]
U_pobs <- pobs(X[,1:11])
colnames(U_pobs) <- c("U1", "U2", "U3","U4", "U5", "U6", "U7","U8", "U9", "U10","U11")
n <- nrow(U_pobs)

# Frank tree - type 5
tree1 <- list(list("U2", list("U9", list("U6", "U7", 7.5), 1.5), 0.7), 
     list(list("U10", "U11", 1.3), list(list(list(list("U1", "U3", 5.25), "U8", 3.9), "U4", 2.7), "U5", 1.8), 0.31), 0.2)
HAC1 <- hac(type = 1, tree = tree1) 
est.tree1 <- estimate.copula(U_pobs, method = 1, hac = HAC1, epsilon = 0.1)
plot(est.tree1)

# Gumbel tree - type 1
tree2 <- list(list(list("U6", "U7", 2), list("U2", "U9", 1.15), 1.05),
      list(list(list(list(list(list("U1", "U8", 1.8), "U3", 1.6), "U4", 1.27), "U5", 1.18), "U10", 1.13), "U11", 1.05), 0.5)
HAC2 <- hac(type = 1, tree = tree2) 
est.tree2 <- estimate.copula(U_pobs, method = 1, hac = HAC2, epsilon = 0.1)
plot(est.tree2)

# Clayton tree - type 3
tree3 <- list(list(list("U11", "U9", 6), "U10", 5), 
              list(list(list(list(list("U1", "U8", 4), "U3", 3), "U4", 2), "U5", 1),
                    list(list("U6", "U7", 2), "U2", 1), 0.5), 0.3)

HAC3 <- hac(type = 3, tree = tree3) 
# error: non-finite value supplied by optim
# est.tree3 <- estimate.copula(U_pobs, method = 1, hac = HAC3, epsilon = 0.1)
# plot(est.tree3)

# method 1 with no predetermined tree structures
est_hac_frank <- estimate.copula(U_pobs, type = 5)
est_hac_frank
plot(est_hac_frank)

est_hac_gumbel <- estimate.copula(U_pobs, type = 1) 
est_hac_gumbel
plot(est_hac_gumbel)

est_hac_clayton <- estimate.copula(U_pobs, type = 3)
est_hac_clayton
plot(est_hac_clayton)
```

### 6. Discussion
### 7. References

\bibliography{bibliography}
\bibliographystyle{plainnat}
